<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=HandheldFriendly content="True">
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta http-equiv=cache-control content="no-transform">
<meta http-equiv=cache-control content="no-siteapp">
<meta name=generator content="Hugo 0.90.1">
<link rel=apple-touch-icon sizes=180x180 href=img/apple-touch-icon.png>
<link rel=icon type=image/png sizes=32x32 href=img/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=img/favicon-16x16.png>
<link rel=manifest href=img/site.webmanifest>
<meta name=msapplication-TileColor content="#da532c">
<meta name=theme-color content="#ffffff">
<title>Apache Thrift Over Unix Sockets in Rust - The Impatient Software Engineer</title>
<meta name=author content="Prateek">
<meta name=description content="IPC over thrift via unix domain sockets">
<meta property="og:title" content="Apache Thrift Over Unix Sockets in Rust">
<meta name=twitter:title content="Apache Thrift Over Unix Sockets in Rust">
<meta property="og:type" content="article">
<meta property="og:url" content="https://prateeknischal.github.io/posts/apache-thrift-over-unix-sockets/"><meta property="og:description" content="IPC over thrift via unix domain sockets">
<meta name=twitter:description content="IPC over thrift via unix domain sockets"><meta property="og:image" content="https://prateeknischal.github.io/img/og.png">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://prateeknischal.github.io/img/og.png"><meta property="article:published_time" content="2020-08-01T01:02:18+05:30"><meta property="article:modified_time" content="2020-08-01T01:02:18+05:30">
<link rel=stylesheet href=https://prateeknischal.github.io/assets/css/fuji.min.css>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-W9Z8MHH4V6')</script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W9Z8MHH4V6"></script>
</head>
<body data-theme=dark data-theme-auto=false>
<script data-cfasync=false>var fujiThemeData=localStorage.getItem('fuji_data-theme');fujiThemeData?fujiThemeData!=='auto'&&document.body.setAttribute('data-theme',fujiThemeData==='dark'?'dark':'light'):localStorage.setItem('fuji_data-theme','auto')</script>
<head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-W9Z8MHH4V6"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-W9Z8MHH4V6',{anonymize_ip:!1})}</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-W9Z8MHH4V6','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
</head>
<main>
<div class="container-lg clearfix">
<div class="col-12 col-md-9 float-left content">
<article>
<h2 class="post-item post-title">
<a href=https://prateeknischal.github.io/posts/apache-thrift-over-unix-sockets/>Apache Thrift Over Unix Sockets in Rust</a>
</h2>
<div class="post-item post-meta">
<span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-08-01</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1644 words</span>
<span><i class="iconfont icon-time-sharp"></i>&nbsp;8 minutes</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;No tag</span>
</div>
<div class="post-content markdown-body">
<p><a href=https://en.wikipedia.org/wiki/Apache_Thrift target=_blank>Apache Thrift</a> is an interace
defintion language and binary communication protocol use for defining and
creating services for all the numerous supported languages. It forms an RPC
framework avoiding the usual microservices HTTP style messaging making it a
bit more efficient avoiding all that HTTP overhead.</p>
<p>Thrift was developed at facebook. Now I have some views about facebook due to
their primary product which is quite stupid (the users), the social network, not the
movie but the website, <a href=https://facebook.com target=_blank>facebook.com</a>. It has almost no
credibility for common people, nothing useful, full of memes (which are
hilarious by the way if you find your way to some awesome math meme pages) and
a serious time killer. There is a <a href="https://www.youtube.com/watch?v=LKPwKFigF8U" target=_blank>video from Veritasium</a>
about how the human mind is getting dull day by day due to these mankind&rsquo;s
effort of filling those spare minutes which could be used for better things.</p>
<p>Too much trash talk now. I actually have started to respect facebook as a tech
innovation company. Facebook has developed some pretty awesome tech like,</p>
<ul>
<li><a href=https://github.com/osquery/osquery target=_blank>osquery</a> - Exposing the OS with an SQL
engine on top of it.</li>
<li><a href=https://github.com/apache/thrift target=_blank>Apache thrift</a> - This article</li>
<li><a href=https://github.com/facebookincubator/katran target=_blank>Katran</a> - A library to build a
high performance L4 loadbalancing forwarding plane using linux&rsquo;s XDP
infrastructure.</li>
<li><a href=https://reactjs.org target=_blank>React</a> - The first choice to build a cross platform UI
application.</li>
<li><a href=https://github.com/facebook/rocksdb target=_blank>RocksDB</a> - A fast multi-core version of
levelDB.</li>
</ul>
<p>and many more !!</p>
<h2 id=what-is-thrift>What is Thrift</h2>
<p>Thrift lets you define an interface for how a service expects input and output.
It&rsquo;s like a unified way of defining a language which then can be
implemented by other languages. It&rsquo;s similar to defining a protocol like
<a href=https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol target=_blank>HTTP</a> which isn&rsquo;t
bound to any language but is a list of guidelines which are implemented by
multiple languages which allows cross language communication across processes,
applications and platforms.</p>
<p>Lets take a look at a dummy interface that just allows reporting a time string.</p>
<pre><code class=language-thrift>service Timer {
    string time()
}
</code></pre>
<p>This service <code>Timer</code> returns a <code>string</code> when calling the <code>Timer.time</code> function.
Thrift works by generating boilerplate code for any supported language. We can
do so by</p>
<pre><code class=language-sh># MacOS install
$ brew install thrfit

# Linux
$ sudo apt install thrift
</code></pre>
<p>or visit <a href=http://thrift.apache.org target=_blank>Project homepage</a> for complete instructions.</p>
<p>Once, thrift is installed, we generate the boilerplate code using</p>
<pre><code class=language-sh>thrift --gen py timer.thrift
</code></pre>
<p>We are using a python codegen for simplicity for the moment. We will do the same
set of activities using Rust as well.</p>
<p>The autogen should generate a folder <code>gen-py</code> with a bunch of python code. Let&rsquo;s
ignore it for now and get a server up and running to make sure it works as
expected.</p>
<pre><code class=language-py>import sys

# Add the generated code to the path so that the boilerplate can be imported.
sys.path.append('./gen-py')
from timer import Timer

from thrift.transport import TSocket, TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer

import time

# Implementation of the Service
class TimerHandler:
    def time(self):
        return str(time.time())

# Handler for the thrift calls are defined and setup
handler = TimerHandler()
proc = Timer.Processor(handler)

socket = TSocket.TServerSocket(port=9090)
transport = TTransport.TBufferedTransportFactory()
protocol = TBinaryProtocol.TBinaryProtocolFactory()
server = TServer.TSimpleServer(proc, socket, transport, protocol)

server.serve()
</code></pre>
<p>Save as <code>server.py</code></p>
<p>This will basically setup the server which now accepts and replies over the thrift
protocol. A client generated from the same interface file can communicate with
this service.</p>
<p>Let&rsquo;s create a client. The boilerplate code exposes a <code>Client</code> class as well
that can be then used to communicate.</p>
<pre><code class=language-python>import sys

# Add the generated code to the path so that the boilerplate can be imported.
sys.path.append('./gen-py')
from timer import Timer

from thrift.transport import TSocket, TTransport
from thrift.protocol import TBinaryProtocol

socket = TSocket.TSocket(port=9090)
transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol.TBinaryProtocol(transport)
client = Timer.Client(protocol)

transport.open()

# Make the call to the server using the generated client.
print (client.time())
transport.close()
</code></pre>
<p>Save as <code>client.py</code></p>
<p>The server can be run by just firing <code>python server.py</code> and then run <code>python client.py</code> to run the client.</p>
<pre><code class=language-sh>$ python server.py &amp;
$ python client.py
1596284880.527916
</code></pre>
<p>Nice and clean !</p>
<h2 id=how-does-it-look>How does it look</h2>
<p>Let&rsquo;s try and take a look at the socket dump of the request. Just set up a
wireshark dump over the loopback and it should recognize the protocol as
<code>THRIFT</code>.</p>
<p><img class=img-zoomable src=/thrift_tcp_capture.png alt="Thrift packets">
</p>
<p>If we take a look at the request packet, it&rsquo;s just a few bits of binary message.
<img class=img-zoomable src=/thrift_request.png alt=Request>
</p>
<p>And the same is for reply, a serialized version of the response is sent as a TCP
package.
<img class=img-zoomable src=/thrift_reply.png alt=Response>
</p>
<p>Describing the protocol would be counter productive and out of scope of this
article (because I don&rsquo;t know how to) as it&rsquo;s a full blown binary
protocol that supports multiple encodings, from pure binary protocol to higher
level JSON protocol and even a space optimized zlib transport.</p>
<h2 id=lets-do-the-client-in-rust>Let&rsquo;s do the client in Rust</h2>
<p>Now that we have a client and server, let&rsquo;s try to make the client in rust (
deal with only one component at a time).</p>
<p>We generate rust code using the <code>thrift</code> CLI.</p>
<pre><code class=language-sh>$ cargo init thrust
$ cd thrust/src
$ thrift --gen rs /path/to/timer.thrift
</code></pre>
<p>This will generate a file called <code>timer.rs</code> with all the boilerplate code and is
simpler than the python code.</p>
<p>Let&rsquo;s write the client in Rust. We can use the Python code for inspiration or
just use the sample code in the <a href=https://docs.rs/thrift target=_blank><code>thrift</code></a> crate&rsquo;s example.</p>
<pre><code class=language-rust>extern crate thrift;
mod timer;

use timer::*;
use thrift::protocol::{TBinaryInputProtocol, TBinaryOutputProtocol};
use thrift::transport::TTcpChannel;

fn main() {
    let mut channel = TTcpChannel::new();
    channel.open(&quot;localhost:9090&quot;).unwrap();

    let (readable, writeable) = channel.split().unwrap();
    let in_stream = TBinaryInputProtocol::new(readable, true);
    let out_stream = TBinaryOutputProtocol::new(writeable, true);

    let mut client = TimerSyncClient::new(in_stream, out_stream);
    println!(&quot;{:?}&quot;, client.time());
}
</code></pre>
<p>If you do a <code>cargo run</code>, It should return a similar output as the python client.
Pretty simple, didn&rsquo;t require a lot of effort, example&rsquo;s got you.</p>
<h2 id=lets-get-into-the-unix-socket>Let&rsquo;s get into the unix socket.</h2>
<p><a href=http://beej.us/guide/bgipc/html/multi/unixsock.html target=_blank>Unix sockets</a>
are Full duplex named sockets that are usually meant for inter-process
communication. It&rsquo;s relatively faster than using the loopback mechanism because
it avoids the data going over the whole TCP Stack that includes the routing
mechanism as well since it&rsquo;s going over an interface. Due to the same reason, it
would be more efficient if we route the thrift traffic over a unix domain socket
instead of localhost.</p>
<p>But, the <code>thrift</code> crate doesn&rsquo;t show any example or API to be able to connect
via Unix Sockets. It only has a
<a href=https://docs.rs/thrift/0.13.0/thrift/transport/struct.TTcpChannel.html target=_blank><code>thrift::transport::TTcpChannel</code></a>
which can&rsquo;t be used with the Unix Sockets as it doesn&rsquo;t use the TCP Stack at
all.</p>
<p>Now, let&rsquo;s see what can be done. Let&rsquo;s explore the <code>TimerSyncClient</code>&rsquo;s
signature from the generated <code>timer.rs</code> file.</p>
<pre><code class=language-rust>pub struct TimerSyncClient&lt;IP, OP&gt; where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl &lt;IP, OP&gt; TimerSyncClient&lt;IP, OP&gt; where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -&gt; TimerSyncClient&lt;IP, OP&gt; {
    TimerSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}
</code></pre>
<p>So, the client needs <code>thrift::protocol::{TInputProtocol, TOuptutProtocol}</code>
for initialization.</p>
<p>Upon inspection of those traits, not much insight is gained.</p>
<p>Let&rsquo;s try looking into the <code>readable</code> and <code>writeable</code> streams that the TCP
example has. <code>thrift::tranport::TIoChannel</code> has a <code>split</code> method that returns a</p>
<pre><code class=language-rust>fn split(self) -&gt; Result&lt;(ReadHalf&lt;Self&gt;, WriteHalf&lt;Self&gt;)&gt;
</code></pre>
<p>Ok, so looks like it needs individual streams to be able to read and write.
Let&rsquo;s inspect these structs.</p>
<p>An instance of the <code>ReadHalf</code> struct can be created as</p>
<pre><code class=language-rust>pub fn new(handle: C) -&gt; ReadHalf&lt;C&gt;
where
    C: Read,
</code></pre>
<p>So, we just need a struct which implements a <code>Read</code> and we should be good
to create a <code>ReadHalf</code> implementation, and same for <code>WriteHalf</code>, we just need a
<code>Write</code> implementation.</p>
<p>Let&rsquo;s roll back to our unix sockets from the standard library.
<a href=https://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html target=_blank><code>std::os::unix::net::UnixStream</code></a></p>
<p>From the docs we see that it has the following traits implemented.</p>
<ul>
<li><a href=https://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#impl-Read target=_blank><code>Read</code></a></li>
<li><a href=https://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html#impl-Write target=_blank><code>Write</code></a></li>
</ul>
<p>Which means, <a href=https://doc.rust-lang.org/std/os/unix/net/struct.UnixStream.html target=_blank><code>UnixStream</code></a>
should suffice. Let&rsquo;s get to it then.</p>
<pre><code class=language-rust>extern crate thrift;
mod timer;

use timer::*;
use thrift::protocol::{TBinaryInputProtocol,TBinaryOutputProtocol};
use std::os::unix::net::UnixStream;
use std::io::prelude::*;

fn main() {
    let socket_tx = UnixStream::connect(&quot;/tmp/timer.sock&quot;).unwrap();
    let socket_rx = socket_tx.try_clone().unwrap();

    let in_proto = TBinaryInputProtocol::new(socket_tx, true);
    let out_proto = TBinaryOutputProtocol::new(socket_rx, true);
    let mut client = TimerSyncClient::new(in_proto, out_proto);

    println!(&quot;{:?}&quot;, client.time());
}
</code></pre>
<p>Change the python server to listen on a unix socket instead of a TCP socket,
i.e.</p>
<pre><code class=language-python>socket = TSocket.TServerSocket(unix_socket='/tmp/timer.sock')
</code></pre>
<p>And, then a <code>cargo run</code> and <strong>Success!!</strong>. We get the time!. Too much trouble to
just get a time string, but it&rsquo;s worth it B).</p>
<blockquote>
<p>Note that we require to clone the socket. This is because
<a href=https://docs.rs/thrift/0.13.0/thrift/protocol/struct.TBinaryInputProtocol.html#method.new target=_blank><code>TBinaryInputProtocol::new</code></a>
takes the ownership of the <code>transport: T</code>. The <code>UnixStream</code> is full duplex,
which means the same object will do a read and write, so we need to get
individual copies of the socket for BinaryIn and BinaryOut protocols.</p>
</blockquote>
<p>And that was it. At the moment, I don&rsquo;t have a good enough understanding of the
rust thrift crate to be able to figure out how to get it to listen on a
Unix Socket since it only has a listen method on a <a href=https://docs.rs/thrift/0.13.0/thrift/server/struct.TServer.html#method.listen target=_blank><code>TSocket</code></a>
struct that accepts a <em>host:port</em> combo.</p>
<pre><code class=language-rust>pub fn listen(&amp;mut self, listen_address: &amp;str) -&gt; Result&lt;()&gt;
</code></pre>
<h2 id=thrift-server-over-tcp>Thrift Server over TCP</h2>
<p>As a consolation, just to make sure, the TCP server works, here is the
implementation. Most of it can be taken from either the python code or
<a href=https://docs.rs/thrift/0.13.0/thrift/server/struct.TServer.html#examples target=_blank>examples</a>
in the <a href=https://docs.rs/thrift target=_blank><code>thrift</code></a> crate.</p>
<pre><code class=language-rust>impl TimerSyncHandler for TimerSyncHandlerImpl {
    fn handle_time(&amp;self) -&gt; thrift::Result&lt;String&gt; {
        return Ok(format!(
            &quot;{:?}&quot;,
            SystemTime::now().duration_since(SystemTime::UNIX_EPOCH)
        ));
    }
}

fn server() {
    let processor = TimerSyncProcessor::new(TimerSyncHandlerImpl {});

    let i_tr_fact: Box&lt;TReadTransportFactory&gt; = Box::new(TBufferedReadTransportFactory::new());
    let i_pr_fact: Box&lt;TInputProtocolFactory&gt; = Box::new(TBinaryInputProtocolFactory::new());
    let o_tr_fact: Box&lt;TWriteTransportFactory&gt; = Box::new(TBufferedWriteTransportFactory::new());
    let o_pr_fact: Box&lt;TOutputProtocolFactory&gt; = Box::new(TBinaryOutputProtocolFactory::new());

    let mut server = TServer::new(i_tr_fact, i_pr_fact, o_tr_fact, o_pr_fact, processor, 10);
    server.listen(&quot;localhost:9090&quot;).unwrap();
}

fn main() {
    let t = thread::spawn(|| { server(); });

    /* client code */
    // The client will connect to the server, print the output and then
    // start listening for other connections.

    t.join().unwrap();
}
</code></pre>
<hr>
<p>For now, the client implementation using unix sockets is sufficient as the aim
for this is to be able to communicate to <code>/var/osquery/osquery.em</code> socket which
I hope is a unix socket.</p>
<hr>
<p>Thanks to <a href=https://www.reddit.com/user/miraunpajaro target=_blank>/u/miraunpajaro</a> for
pointing out mistakes in the article.</p>
<p>Discussion thread <a href=https://www.reddit.com/r/rust/comments/i70l4b/apache_thrift_over_unix_sockets_in_rust/ target=_blank>here</a></p>
</div>
</article>
<div class="license markdown-body">
<blockquote>
<p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p>
</blockquote>
</div>
</div>
<aside class="col-12 col-md-3 float-left sidebar">
<div class="sidebar-item sidebar-pages">
<h3>Pages</h3>
<ul>
<li>
<a href=/posts>Home</a>
</li>
<li>
<a href=/about/>About</a>
</li>
<li>
<a href=/index.xml>RSS</a>
</li>
</ul>
</div>
<div class="sidebar-item sidebar-links">
<h3>Links</h3>
<ul>
<li>
<a href=https://github.com/prateeknischal target=_blank><span>GitHub</span></a>
</li>
<li>
<a href=https://twitter.com/pikaynu target=_blank><span>Twitter</span></a>
</li>
</ul>
</div>
<div class="sidebar-item sidebar-tags">
<h3>Tags</h3>
<div>
</div>
</div>
<div class="sidebar-item sidebar-toc">
<h3>Table of Contents</h3><nav id=TableOfContents>
<ul>
<li><a href=#what-is-thrift>What is Thrift</a></li>
<li><a href=#how-does-it-look>How does it look</a></li>
<li><a href=#lets-do-the-client-in-rust>Let&rsquo;s do the client in Rust</a></li>
<li><a href=#lets-get-into-the-unix-socket>Let&rsquo;s get into the unix socket.</a></li>
<li><a href=#thrift-server-over-tcp>Thrift Server over TCP</a></li>
</ul>
</nav></div>
</aside>
</div>
<div class=btn>
<div class=btn-menu id=btn-menu>
<i class="iconfont icon-grid-sharp"></i>
</div>
<div class=btn-toggle-mode>
<i class="iconfont icon-contrast-sharp"></i>
</div>
<div class=btn-scroll-top>
<i class="iconfont icon-chevron-up-circle-sharp"></i>
</div>
</div>
<aside class=sidebar-mobile style=display:none>
<div class=sidebar-wrapper>
<div class="sidebar-item sidebar-pages">
<h3>Pages</h3>
<ul>
<li>
<a href=/posts>Home</a>
</li>
<li>
<a href=/about/>About</a>
</li>
<li>
<a href=/index.xml>RSS</a>
</li>
</ul>
</div>
<div class="sidebar-item sidebar-links">
<h3>Links</h3>
<ul>
<li>
<a href=https://github.com/prateeknischal target=_blank><span>GitHub</span></a>
</li>
<li>
<a href=https://twitter.com/pikaynu target=_blank><span>Twitter</span></a>
</li>
</ul>
</div>
<div class="sidebar-item sidebar-tags">
<h3>Tags</h3>
<div>
</div>
</div>
<div class="sidebar-item sidebar-toc">
<h3>Table of Contents</h3>
<nav id=TableOfContents>
<ul>
<li><a href=#what-is-thrift>What is Thrift</a></li>
<li><a href=#how-does-it-look>How does it look</a></li>
<li><a href=#lets-do-the-client-in-rust>Let&rsquo;s do the client in Rust</a></li>
<li><a href=#lets-get-into-the-unix-socket>Let&rsquo;s get into the unix socket.</a></li>
<li><a href=#thrift-server-over-tcp>Thrift Server over TCP</a></li>
</ul>
</nav>
</div>
</div>
</aside>
</main>
<footer>
<div class="container-lg clearfix">
<div class="col-12 footer">
<span>&copy; 2020-2021
<a href=https://prateeknischal.github.io>Prateek</a>
| <a href=https://github.com/prateeknischal/prateeknischal.github.io>Source code</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a>
</span>
</div>
</div>
</footer>
<script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script>
<script defer src=/assets/js/fuji.min.js></script>
</body>
</html>